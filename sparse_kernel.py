# -*- coding: utf-8 -*-
"""sparse_kernel

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13dmIFMTTwXUx5ybmgHxBQvrR2h-3aNdD
"""

import torch
import numpy as np
import torch.nn as nn

def unfold_sparse_1D(input_tensor, indices):
  ''' input must be np arrays '''
  
  # Find the amount of zero padding needed to make the output the same
  # size as the input.
  low_pad = max(0 - min(indices), 0)
  high_pad = max(0, max(indices))

  input_array = input_tensor.numpy()
  padded_array = np.concatenate((input_array, np.zeros(high_pad), np.zeros(low_pad)))

  # Construct an array of indices for fancy indexing that slides 
  # along the input array.
  indices = np.arange(len(input_array))[:, np.newaxis] + indices
  print(indices)

  return torch.tensor(padded_array[indices], dtype=torch.float32)

def unfold_sparse_2D(input_tensor, indices):
  ''' indices should come in the form of a list of coordinate pairs. '''
  
  # Find the amount of zero padding needed to make the output the same
  # size as the input.
  left_pad = max(0, 0-np.min(k[:,1]))
  top_pad = max(0, 0-np.min(k[:,0]))
  right_pad = max(0, np.max(k[:,1]))
  bottom_pad = max(0, np.max(k[:,0]))
  #print (left_pad, top_pad, right_pad, bottom_pad)

  input_array = input_tensor.numpy()
  padded_array = np.hstack((input_array, np.zeros((input_array.shape[0], right_pad + left_pad))))
  padded_array = np. vstack((padded_array, np.zeros((bottom_pad + top_pad, padded_array.shape[1]))))
  
  # Construct an array of indices for fancy indexing that slides 
  # along the input array.
  axis0_coords =  np.arange(input_array.shape[0], dtype=int) [:, np.newaxis] * np.ones(input_array.shape[1], dtype=int)
  axis1_coords =  np.ones(input_array.shape[0], dtype=int)[:, np.newaxis] * np.arange(input_array.shape[1], dtype=int)[np.newaxis, :] 
 
  axis0_ix = (axis0_coords[np.newaxis, :, :] + k[:,1][:,np.newaxis,np.newaxis])
  axis1_ix = (axis1_coords[np.newaxis, :, :] + k[:,0][:,np.newaxis,np.newaxis])
  
  return torch.tensor(padded_array[axis0_ix, axis1_ix], dtype=torch.float32)

def harmonic_conv_1D(input_array, sparse_kernel_indices, sparse_kernel_values):
  indices = torch.tensor(unfold_sparse_1D(input_array, sparse_kernel_indices))
  print(indices.shape)
  print(sparse_kernel_values.unsqueeze(1).shape)
  return torch.mm(indices, sparse_kernel_values.unsqueeze(1)).squeeze()

def harmonic_conv_2D(input_tensor, sparse_kernel_indices, sparse_kernel_values):
  unfolded = unfold_sparse_2D(input_tensor, sparse_kernel_indices)
  orig_shape = unfolded.shape
  linear_unfolded = torch.tensor(unfolded.reshape(orig_shape[0], orig_shape[1] * orig_shape [2]), dtype=float)
  linear_out = torch.mm(sparse_kernel_values.unsqueeze(0), linear_unfolded)
  return torch.reshape(linear_out, (orig_shape[1], orig_shape[2]))

input_tensor = torch.arange(20).reshape(4,5)
k = np.array([[-2, -1], [0,0], [1, 2]])
harmonic_conv_2D(input_tensor, k, torch.tensor([1,2,3], dtype=float))

class HarmonicConv_1D(nn.Module):
  
  def __init__(self, frames, indices):
    super(HarmonicConv_1D, self).__init__()
    self.sparse_kernel_indices = indices
    self.sparse_kernel_values = torch.randn(frames, len(indices))
    # print('self.sparse_kernel_values\n', self.sparse_kernel_values)

  def unfold_sparse_1D(self, input_tensor, indices):
    # Find the amount of zero padding needed to make the output the same
    # size as the input.
    low_pad = max(0 - min(indices), 0)
    high_pad = max(0, max(indices))
    input_array = input_tensor.numpy()
    padded_array = np.concatenate((input_array, np.zeros(high_pad), np.zeros(low_pad)))
    # print('padded array\n', padded_array)

    # Construct an array of indices for fancy indexing that slides 
    # along the input array.
    indices = np.arange(len(input_array))[:, np.newaxis] + indices
    #print(indices)

    return torch.tensor(padded_array[indices], dtype=torch.float32)


  def forward(self, input_array):
    unfolded = torch.tensor(self.unfold_sparse_1D(input_array, self.sparse_kernel_indices))
    # print('unfolded\n', unfolded)
    # print(unfolded.shape)
    # print(self.sparse_kernel_values.shape)
    return torch.mm(self.sparse_kernel_values, unfolded.T)



a = torch.tensor(np.linspace(0, 5, 6))
kernel_indices = (0,3,7)
hc1d = HarmonicConv_1D(4, kernel_indices)
out = hc1d(a)
print(out)

# I'm leaving this version in here for now. It has a lot of debugging print statements. 

# class HarmonicConv_2D(nn.Module):

#   def __init__(self, frames, indices):
#     super(HarmonicConv_2D, self).__init__()
#     self.sparse_kernel_indices = indices 
#     # self.sparse_kernel_values = torch.randn(frames, indices.shape[0])
#     self.sparse_kernel_values = torch.tensor([[0.1, 0.2, 0.3], [0.01, 0.02, 0.03]], dtype = torch.float32)
#     print ('self.sparse_kernel_values\n', self.sparse_kernel_values)

#   def unfold_sparse_2D(self, input_tensor, indices):
#     ''' indices should come in the form of a list of coordinate pairs. '''
    
#     # Find the amount of zero padding needed to make the output the same
#     # size as the input.
#     left_pad = max(0, 0-np.min(indices[:,0]))
#     top_pad = max(0, 0-np.min(indices[:,1]))
#     right_pad = max(0, np.max(indices[:,0]))
#     bottom_pad = max(0, np.max(indices[:,1]))
#     print ('left_pad, top_pad, right_pad, bottom_pad: ', left_pad, top_pad, right_pad, bottom_pad)

#     input_array = input_tensor.numpy()
#     padded_array = np.hstack((input_array, np.zeros((input_array.shape[0], right_pad + left_pad))))
#     padded_array = np. vstack((padded_array, np.zeros((bottom_pad + top_pad, padded_array.shape[1]))))
#     print('padded_array\n', padded_array)
    
#     # Construct an array of indices for fancy indexing that slides 
#     # along the input array.
#     axis0_coords =  np.arange(input_array.shape[0], dtype=int) [:, np.newaxis] * np.ones(input_array.shape[1], dtype=int)
#     print('axis0_coords\n', axis0_coords)
#     axis1_coords =  np.ones(input_array.shape[0], dtype=int)[:, np.newaxis] * np.arange(input_array.shape[1], dtype=int)[np.newaxis, :] 
#     print('axis1_coords\n', axis1_coords)
  
#     axis0_ix = (axis0_coords[np.newaxis, :, :] + indices[:,1][:,np.newaxis,np.newaxis])
#     print('axis0_ix\n',axis0_ix)
#     axis1_ix = (axis1_coords[np.newaxis, :, :] + indices[:,0][:,np.newaxis,np.newaxis])
#     print('axis1_ix\n',axis1_ix)
#     return torch.tensor(padded_array[axis0_ix, axis1_ix], dtype=torch.float32)

#   def forward(self, input_array):
#     unfolded = torch.tensor(self.unfold_sparse_2D(input_array, self.sparse_kernel_indices), dtype = torch.float32)
#     print ('unfolded\n', unfolded)
#     orig_shape = unfolded.shape
#     print('orig_shape\n',orig_shape)
#     linear_unfolded = unfolded.reshape(orig_shape[0], orig_shape[1] * orig_shape [2])
#     print('linear unfolded\n', linear_unfolded)
#     print('linear_unfolded.shape', linear_unfolded.shape)
#     print('self.sparse_kernel_values.shape', self.sparse_kernel_values.shape)
#     linear_out = torch.mm(self.sparse_kernel_values, linear_unfolded)
#     return linear_out.reshape(self.sparse_kernel_values.shape[0], orig_shape[1], orig_shape[2])

class HarmonicConv_2D(nn.Module):

  def __init__(self, frames, indices):
    super(HarmonicConv_2D, self).__init__()
    self.sparse_kernel_indices = indices 
    self.sparse_kernel_values = torch.randn(frames, indices.shape[0])
   
  def unfold_sparse_2D(self, input_tensor, indices):
    ''' indices should come in the form of a list of coordinate pairs. '''
    
    # Find the amount of zero padding needed to make the output the same
    # size as the input.
    left_pad = max(0, 0-np.min(indices[:,0]))
    top_pad = max(0, 0-np.min(indices[:,1]))
    right_pad = max(0, np.max(indices[:,0]))
    bottom_pad = max(0, np.max(indices[:,1]))
  
    input_array = input_tensor.numpy()
    padded_array = np.hstack((input_array, np.zeros((input_array.shape[0], right_pad + left_pad))))
    padded_array = np. vstack((padded_array, np.zeros((bottom_pad + top_pad, padded_array.shape[1]))))
  
    
    # Construct an array of indices for fancy indexing that slides 
    # along the input array.
    axis0_coords =  np.arange(input_array.shape[0], dtype=int) [:, np.newaxis] * np.ones(input_array.shape[1], dtype=int)
    axis1_coords =  np.ones(input_array.shape[0], dtype=int)[:, np.newaxis] * np.arange(input_array.shape[1], dtype=int)[np.newaxis, :] 
    
    axis0_ix = (axis0_coords[np.newaxis, :, :] + indices[:,1][:,np.newaxis,np.newaxis])
    axis1_ix = (axis1_coords[np.newaxis, :, :] + indices[:,0][:,np.newaxis,np.newaxis])
    return torch.tensor(padded_array[axis0_ix, axis1_ix], dtype=torch.float32)

  def forward(self, input_array):
    unfolded = torch.tensor(self.unfold_sparse_2D(input_array, self.sparse_kernel_indices), dtype = torch.float32)
    orig_shape = unfolded.shape
    linear_unfolded = unfolded.reshape(orig_shape[0], orig_shape[1] * orig_shape [2])
    linear_out = torch.mm(self.sparse_kernel_values, linear_unfolded)
    return linear_out.reshape(self.sparse_kernel_values.shape[0], orig_shape[1], orig_shape[2])

a = torch.arange(90).reshape(9,10)
kernel_indices = np.array([[-2,-1], [0,0], [3, 4]])
hc2d = HarmonicConv_2D(2, kernel_indices)
print(a)
print (kernel_indices)
hc2d(a)